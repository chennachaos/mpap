

#include "headersBasic.h"

#include "StandardFEM.h"
#include "MathBasic.h"
#include "DataBlockTemplate.h"
#include "ComputerTime.h"
#include "MpapTime.h"
#include "TimeFunction.h"
#include "PlotVTK.h"
#include "PropertyTypeEnum.h"

#include "Global.h"
#include "MyString.h"
#include "FunctionsEssGrp.h"

#include "UnixGlobal.h"

#include <omp.h>


extern DomainTree         domain;
extern List<TimeFunction> timeFunction;
extern MpapTime           mpapTime;
extern ComputerTime       computerTime;
extern PlotVTK  plotvtk;


using namespace std;



//
int main(int argc, char* argv[])
{
  // FSI with standard elements
  // Example from the paper 
  // Stabilization of explicit coupling in fluid–structure interaction involving fluid incompressibility
  // by
  // Erik Burman a, Miguel A. Fernández
  //

    int parm[5], ii, jj, kk, iter, niter=10, solv=1;
    parm[0] = 2;

    int  resln[]={1,1,1};
    int tis = 3 ;
    double  tol = 1.0e-5;
    double  rho = 0.8;

    vector<double>  stagParams(3);

    stagParams[0] = 0;
    stagParams[1] = 2.0;
    stagParams[2] = 1.2/(1.0+1.2)/200.0;

    files.projDir = "../src/test/" ;
    files.Ifile = "Ioutput";
    files.Ofile.free().append(files.Ifile)[0] = 'O';
    files.Tfile.free().append(files.Ifile)[0] = 'T';
    files.Pfile.free().append(files.Ifile)[0] = 'P';

    cout << "       project directory   : " << files.projDir << "\n";
    cout << "       input file name     : " << files.Ifile << "\n";
    cout << "       output file name    : " << files.Ofile << "\n";
    cout << "       time plot file name : " << files.Tfile << "\n";
    cout << "       eps plot file name  : " << files.Pfile << "\n\n";  


    // ==================================================
    //
    // prepare input data for the solid problem
    //
    // ==================================================

    StandardFEM  sfemSolid;


    sfemSolid.SetDimension(2);

    sfemSolid.setNdof(2);


    // set nodes and elements
    ///////////////////////////////////////

    double  x0S = 0.0,  y0S = 0.5;
    double  x1S = 5.0,  y1S = 0.6;

    int  nExS = 100, nEyS = 4;

    int  nElemSolid = nExS*nEyS;

    int  nNxS = nExS+1;
    int  nNyS = nEyS+1;

    int  nNodeSolid = nNxS*nNyS;

    double  dxS = (x1S-x0S)/nExS;
    double  dyS = (y1S-y0S)/nEyS;

    vector<vector<double> >  nodesSolid;
    vector<vector<int> >     elemsSolid;

    nodesSolid.resize(nNodeSolid);

    for(ii=0;ii<nNodeSolid;ii++)
      nodesSolid[ii].resize(2);

    double  xx, yy;

    kk=0;
    yy=y0S;
    for(jj=0;jj<=nEyS;jj++)
    {
      xx=x0S;
      for(ii=0;ii<=nExS;ii++)
      {
        nodesSolid[kk][0] = xx;
        nodesSolid[kk][1] = yy;
        xx += dxS;
      }
      yy += dyS;
      kk++;
    }


    elemsSolid.resize(nElemSolid);

    for(ii=0;ii<nNodeSolid;ii++)
      elemsSolid[ii].resize(7);


    int  ind2, ind3, n1, n2, n3, n4;

    kk=0;
    for(jj=0;jj<=nEyS;jj++)
    {
      ind2 = nNxS*jj;
      ind3 = nNxS*(jj+1);

      for(ii=0;ii<=nExS;ii++)
      {
        n1 = ind2 + ii;
        n2 = n1+1;

        n3 = ind3 + ii;
        n4 = n3+1;

        elemsSolid[kk][0] = 1;
        elemsSolid[kk][1] = 1;
        elemsSolid[kk][2] = 1;

        elemsSolid[kk][3] = n1;
        elemsSolid[kk][4] = n2;
        elemsSolid[kk][5] = n3;
        elemsSolid[kk][6] = n4;

        kk++;
      }
    }


    sfemSolid.SetControl(tis, tol, rho);

    sfemSolid.SolnData.SetStaggeredParams(stagParams);
    
    sfemSolid.SetSolidOrFluid(1);

    sfemSolid.SetVTKfilename("FSIsolid");

    //sfemSolid.prepareInputData();
  
    cout << " Solid model preparation successful " << endl;

    sfemSolid.setSolver(solv, parm);

    cout << " Solid solver preparation successful " << endl;
  
    // ==================================================
    //
    // prepare input data for the fluid problem
    //
    // ==================================================

    StandardFEM  sfemFluid;

    sfemFluid.SetDimension(2);

    sfemFluid.setNdof(3);


    // set nodes and elements
    ///////////////////////////////////////

    double  x0F = 0.0,  y0F = 0.0;
    double  x1F = 5.0,  y1F = 0.5;

    double  nExF = 100, nEyF = 10;

    int  nElemFluid = nExF*nEyF;

    int  nNxF = nExF+1;
    int  nNyF = nEyF+1;

    int  nNodeFluid = nNxF*nNyF;

    double  dxF = (x1F-x0F)/nExF;
    double  dyF = (y1F-y0F)/nEyF;

    vector<vector<double> >  nodesFluid;
    vector<vector<int> >     elemsFluid;

    nodesFluid.resize(nNodeFluid);

    for(ii=0;ii<nNodeFluid;ii++)
      nodesFluid[ii].resize(2);

    kk=0;
    yy=y0F;
    for(jj=0;jj<=nEyF;jj++)
    {
      xx=x0F;
      for(ii=0;ii<=nExF;ii++)
      {
        nodesFluid[kk][0] = xx;
        nodesFluid[kk][1] = yy;
        xx += dxF;
      }
      yy += dyF;
      kk++;
    }


    elemsFluid.resize(nElemFluid);

    for(ii=0;ii<nNodeFluid;ii++)
      elemsFluid[ii].resize(7);


    kk=0;
    for(jj=0;jj<=nEyF;jj++)
    {
      ind2 = nNxF*jj;
      ind3 = nNxF*(jj+1);

      for(ii=0;ii<=nExF;ii++)
      {
        n1 = ind2 + ii;
        n2 = n1+1;

        n3 = ind3 + ii;
        n4 = n3+1;

        elemsFluid[kk][0] = 1;
        elemsFluid[kk][1] = 1;
        elemsFluid[kk][2] = 1;

        elemsFluid[kk][3] = n1;
        elemsFluid[kk][4] = n2;
        elemsFluid[kk][5] = n3;
        elemsFluid[kk][6] = n4;

        kk++;
      }
    }


    sfemFluid.SetControl(tis, tol, rho);

    sfemFluid.SetSolidOrFluid(0);

    sfemFluid.SetVTKfilename("FSIfluid");

    //sfemFluid.prepareInputData();
  
    cout << " Fluid model preparation successful " << endl;

    sfemFluid.setSolver(solv, parm);

    cout << " Fluid solver preparation successful " << endl;
  
    // ==================================================
    //
    // set the interface nodes
    //
    // ==================================================

    int  nNodeIntf=101;

    vector<int>  intfFluid(nNodeIntf), intfSolid(nNodeIntf);

    for(ii=0; ii<nNodeIntf; ii++)
    {
      intfFluid[ii] = 1010+ii;
      intfSolid[ii] = ii;
    }


    // ==================================================
    //
    // set the time function(s)
    //
    // ==================================================


    timeFunction.add(new TimeFunction);

    timeFunction[0].fct.add(new TimeFunctionCore);

    timeFunction[0].fct[0].t0 = 0.0;
    timeFunction[0].fct[0].t1 = 10.0;

    timeFunction[0].fct[0].p[0] = 1.0;
    timeFunction[0].fct[0].p[1] = 0.0;
    timeFunction[0].fct[0].p[2] = 0.0;
    timeFunction[0].fct[0].p[3] = 0.0;
    timeFunction[0].fct[0].p[4] = 0.0;
    timeFunction[0].fct[0].p[5] = 0.0;

    timeFunction[0].fct[0].tp = 1.0e+30;

    for(ii=0; ii<timeFunction.n; ii++)
      timeFunction[ii].update();


    double  dt=0.0001, tf=0.001, tCur;



    mpapTime.dtOK     = true;
    mpapTime.dt       = dt;
    mpapTime.dtMax    = dt;
    mpapTime.stack.free();
    mpapTime.stack.append(mpapTime.dt);
    if(mpapTime.dtMax < 1.e-15)
      mpapTime.dtMax = mpapTime.dt;

    niter = 10;
    tCur  = dt;

    sfemSolid.SolnData.SetStaggeredParams(stagParams);
    sfemFluid.SolnData.SetStaggeredParams(stagParams);

    while(tCur <= tf)
    {
        mpapTime.cur = tCur;
        // compute force predictor on the solid
        ///////////////////////////

        sfemSolid.setTimeParam();

        sfemSolid.timeUpdate();

        // solve solid problem
        ///////////////////////////

        cout << " solving solid problem ... " << endl;

        sfemSolid.SolveStep(niter);

        //printVector(sfemSolid.SolnData.var1Cur);

        cout << " solving solid problem ... DONE " << endl;

        sfemSolid.writeNodalData();

        sfemSolid.postProcess(0, 0, 1, 0, 0.0, 1.0, resln);


        // update fluid mesh and 
        // velocity BCs for the fluid problem
        ///////////////////////////

        sfemFluid.SolnData.var1applied.setZero();
        for(ii=0; ii<intfFluid.size(); ii++)
        {
          for(jj=0; jj<2; jj++)
          {
            //cout << ii << '\t' << sfemSolid.SolnData.var1DotCur[intfSolid[ii]*2+jj] << endl;
            sfemFluid.SolnData.var1applied[intfFluid[ii]*3+jj] = sfemSolid.SolnData.var1Dot[intfSolid[ii]*2+jj];
          }
        }

        cout << " kkkkkkkkkkk " << endl;


        // solve fluid problem
        ///////////////////////////

        sfemFluid.setTimeParam();

        sfemFluid.timeUpdate();


        cout << " solving fluid problem ... " << endl;

        sfemFluid.SolveStep(niter);

        cout << " solving fluid problem ... DONE " << endl;

        //sfemFluid.writeNodalData();

        sfemFluid.postProcess(0, 0, 1, 0, 0.0, 1.0, resln);

        ///////////////////////////
        // compute the force corrector
        ///////////////////////////

        sfemSolid.SolnData.forceTemp.setZero();
        for(ii=0; ii<intfFluid.size(); ii++)
        {
            //cout << ii << '\t' << jj << '\t' << sfemFluid.SolnData.reac[intfFluid[ii]*3+1] << endl;
          for(jj=0; jj<2; jj++)
          {
            //cout << ii << '\t' << jj << '\t' << sfemFluid.SolnData.reac[intfFluid[ii]*3+jj] << endl;
            sfemSolid.SolnData.forceTemp[intfSolid[ii]*2+jj] = sfemFluid.SolnData.reac[intfFluid[ii]*3+jj];
          }
        }

        sfemSolid.SolnData.interpolateForce();

        tCur += dt;
    }

    cout << " \n\n\n Propgram successful ... \n\n\n " << endl;


  return 0;
}











